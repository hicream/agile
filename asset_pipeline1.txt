CSS 和 ERB
资源管道自动计算ERB。一旦在CSS资源上加上erb的扩展名(比如：app.css.erb)，那么像asset_path这样的帮助器就可以用在css中，例如：
    .class {background-image: url(<%= asset_path 'image.png' %>)}
    在资源加载时会指向 app/assets/images/image.png。若采用 data URI的方式，可以使用asset_data_rui帮助器，例如：
    #logo {background: url(<%= asset_data_uri 'logo.png' %>)}
CSS和Sass
   使用资源管道时，图片、字体、视频、音频、JS和CSS等资源的路径必须重写，并且 sass-rails 提供了 -url和 -path 帮助器，用法如下：
        image-url("rails.png") becomes url(/assets/rails.png)
        image-path("rails.png") becomes "/assets/rails.png"
    也可以使用更常规的方法，但是必须指定资源路径而且类型也必须要指定：
        asset-url("rails.png", image) becomes url(/asset/rails.png)
        asset-path("rails.png", image) becomes "/assets/rails.png"JS/CoffeeScript 和 ERB
    若在JS文件后加上erb的后缀(比如：app.js.erb)，那么在JS代码中就可以使用asset_path 帮助器，比如：
        $('#logo').attr({src: "<%= asset_path('logo.png') %>"});
    与之类似，在CoffeeScript文件后加上erb后缀(比如：app.js.coffee.erb)，可以使用asset_path帮助器，比如：
        $('#logo').attr src: "<%= asset_path('logo.png') %>"
3、资源清单和指令
    Sprockets 使用资源清单文件，以此来决定哪些文件会被包含，并提供服务。这些文件中包含指令，Srockets可以识别哪些文件可以按顺序合并成单独的css文件和js文件。可以使用的指令包括 require和require_tree。require指令告诉Sprockets哪些文件时必须的。require_tree指令告诉Sprockets在指定的目录下所有的js文件都需要，这个路径必须是相当资源清单文件的地址。当然也可以使用require_directory，指定某个目录，但不包含递归。还有其他的指令，比如require_self等。
4、预处理
    文件的扩展名决定其是否会被预处理。使用默认的gem集生成控制器时，一个CoffeeScript和一个SCSS文件会生成，比如：app/assets/javascripts/project.js.coffee和app/assets/stylesheets/project.css.scss。当请求这些文件时，coffee-script 和sass的gem包会将他们处理成对应的css和js文件。预处理可以加入其他的层，扩展名会被自右向左处理，比如：app/assets/stylesheets/projects.css.scss.erb文件，会先由ERB处理，再由SCSS处理，最后提供css。
三、开发环境
    开发模式下，资源清单中的文件会被独立显示，不会被合并成独立的文件
1、关闭调试：
    在config/environments/development.rb文件中更改为config.assets.debug = false。当关闭调试时，资源清单中的文件会被合并成单独的文件。服务启动在第一次访问时，资源会被编译并缓存。Sprockets会设置 must-revalidate Cache-Control 请求头验证，以便减少服务器压力。如果在服务期间，资源清单中的文件更改，服务器会响应新的文件。
    调试模式在Rails帮助器中开启，比如：
        <%= stylesheets_link_tag "application", :debug => true %>
        <%= javascript_include_tag "application", :debug => true %>
四、生产环境
    在生产环境中，Rails使用上面概述的指纹方案。默认Rails会假设资源已经预编译并且会以静态文件的方式提供服务。
1、预编译资源
    Rails捆绑了一个 rake 命令，可以编译资源清单和资源管线中的其他文件生成到硬盘中，默认位置为 public/assets 目录。
    可以在创建资源的编译版本来部署时，调用这个任务。rake任务如下：        bundle exec rake assets:precomile
    为了更快的执行资源预编译，可以通过在config/application.rb文件中设置config.assets.initialize_on_precompile为false执行部分加载。
    默认编译application.js，application.css和所有非js和css的文件(.coffee和.scss不会被自动包含进去，因为他们编译成js和css文件)
    [ Proc.new{ |path| !File.extname(path).in?(['.js', '.css']) }, /application.(css|js)$/ ]
    若有其他的资源清单或者分离的css和js文件需要包含进去，可以将他们放到预编译数组中，例如：
    config.assets.precompile += ['admin.js', 'admin.css', 'swfObject.js']
    rake 命令会生成一个 manifest.yml 的文件，包含所有的资源名称和他们对应的指纹码。典型的资源清单如下：
    ---
    rails.png: rails-bd9ad5a560b5a3a7be0808c5cd76a798.png
    jquery-ui.min.js: jquery-ui-7e33882a28fc84ad0e0e47e46cbf901c.min.js
    jquery.min.js: jquery-8a50feed8d29566738ad005e19fe1c2d.min.js
    application.js: application-3fdab497b8fb70d20cfc5495239dfc29.js
    application.css: application-8af74128f904600e41a6e39241464e03.css
    默认的资源清单在config.assets.prefix指定的路径根目录下(默认为/assets)。可以在 config.assets.manifest选项中指定绝对路径：
    config.assets.manifest = '/path/to/some/other/location'
2、服务配置
    预编译过的资源存在于磁盘上并且通过web服务器提供服务。但是并不会默认设置销毁头，因此为了体现指纹的优势，需要做以下配置：
    Apache的配置：
        <LocationMatch "^/assets/.*$">
          Header unset ETag
          FileETag None
          # RFC says only cache for 1 year
          ExpiresActive On
          ExpiresDefault "access plus 1 year"
        </LocationMatch>
    Nginx的配置：
        location ~ ^/assets/ {
          expires 1y;
          add_header Cache-Control public;
         
          add_header ETag "";
          break;
        }
    Sprockets会创建资源的gzip压缩版本。web服务器的典型配置是使用中度压缩，但是由于已经进行了预编译，Sprocket会使用最大的压缩率，因此减少了数据传输量。另一方面，web服务器可配置成从硬盘中获取压缩好的内容直接提供服务。Nginx的配置如下：
        location ~ ^/(assets)/  {
          root /path/to/public;
          gzip_static on; # to serve pre-gzipped version
          expires max;
          add_header Cache-Control public;
        }
3、及时编译(Live Compilation)
    某些情况下，需要使用及时编译模式。在这个模式中所有的资源的请求都由Sprockets直接处理，可以通过下面的语句开启：
        config.assets.compile = true
    第一次请求时资源会被编译并缓存，而且在帮助器中使用的资源名称也会加上 MD5的标识。Sprockets，会为这些资源加上 Cache-Control 的HTTP头，其中max-age=31536000
    这种模式会消耗更多的内存，性能较差，不推荐使用。
    若部署生产应用时不存在任何的JavaScript运行时，会出错，需要在Gemfile文件中加入以下引用：
        group :production do
          gem 'therubyracer'
        end
五、自定义管线
1、CSS 压缩
    这里有另外一个CSS压缩工具 YUI。启用YUI压缩如下：
        config.assets.css_compressor = :yui
        config.assets.compress = true
    需要添加 yui-compressor 的gem。
2、JS压缩
    JS压缩工具有 closure，uglifier，yui，他们对应的gem如下：closure-compiler，uglifier，yui-compressor。Ruby默认的压缩是uglifier。
3、使用自己的压缩工具
    CSS和JS的的压缩配置需要定义一个对象，并且对应必须存在 compress的方法，该方法有个字符串参数，必须返回一个字符串，范例如下：
        class Transformer
          def compress(string)
            do_something_returning_a_string(string)
          end
        end
    在application.rb中按下面的方式修改，会使配置生效：
        config.assets.css_compressor = Transformer.new
4、改变 assets 的路径
    Sprockets的默认公共路径为 /assets。更改路径的设置为：
        config.assets.prefix = "/some_other_path"
    这在已经存在的工程中，使用新的资源的路径时很有用。
5、X-Sendfile Headers
    X-Sendfile 头表示指向web服务器忽略应用的响应，并从磁盘上直接提供文件服务。这个功能默认关闭。如果打开，文件服务会更快。Apache和Nginx支持这个配置：
        config.action_dispatch.x_sendfile_header = "X-Sendfile" # for apache
        config.action_dispatch.x_sendfile_header = 'X-Accel-Redirect' # for nginx


生产环境中public的作用，全文搜索public
预编译在何时完成

